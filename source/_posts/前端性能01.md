---
title: 函数节流和函数防抖
date: 2019-04-23
tags:
  - IT技术
  - 前端
  - 性能
---

### 概念
```
在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时
```

#### 看一个栗子：
```
// 未节流之前的代码

// 模拟ajax请求
function ajax(con){
    console.log('ajax'+ con);
}

var inputTextA = document.getElementById('texta');

inputTextA.addEventListener('keyup', function(e){
    ajax(e.target.value)
})
```

![未节流的操作示例](https://img-blog.csdn.net/20180905153946976?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbl9iaW5vYmplY3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```
// 进行节流操作
    function ajax(content) {
        console.log('ajax request ' + content)
    }

    function debounce(fun, delay) {
        return function (args) {
            let that = this
            let _args = args
            clearTimeout(fun.id)
            fun.id = setTimeout(function () {
                fun.call(that, _args)
            }, delay)
        }
    }

    let inputb = document.getElementById('testa')

    let debounceAjax = debounce(ajax, 500)

    inputb.addEventListener('keyup', function (e) {
        debounceAjax(e.target.value)
    })
```

![节流之后的操作示例](https://img-blog.csdn.net/20180905155250717?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbl9iaW5vYmplY3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)